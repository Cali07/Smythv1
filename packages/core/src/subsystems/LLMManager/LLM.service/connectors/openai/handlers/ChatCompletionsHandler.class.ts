import EventEmitter from 'events';
import { BUILT_IN_MODEL_PREFIX } from '@sre/constants';
import { TLLMEvent, APIKeySource } from '@sre/types/LLM.types';
import { IResponseHandler, HandlerDependencies } from '../types';
import type { ILLMRequestContext } from '@sre/types/LLM.types';

// per 1k requests
const costForNormalModels = {
    low: 30 / 1000,
    medium: 35 / 1000,
    high: 50 / 1000,
};
const costForMiniModels = {
    low: 25 / 1000,
    medium: 27.5 / 1000,
    high: 30 / 1000,
};

const SEARCH_TOOL = {
    type: 'web_search_preview' as const,
    cost: {
        'gpt-4.1': costForNormalModels,
        'gpt-4o': costForNormalModels,
        'gpt-4o-search': costForNormalModels,

        'gpt-4.1-mini': costForMiniModels,
        'gpt-4o-mini': costForMiniModels,
        'gpt-4o-mini-search': costForMiniModels,
    },
};

export class ChatCompletionsHandler implements IResponseHandler {
    constructor(private deps: HandlerDependencies) {}

    async createStream(body: any, context: ILLMRequestContext): Promise<any> {
        const openai = await this.deps.getClient(context);
        return await openai.chat.completions.create({...body, stream: true, stream_options: { include_usage: true }});
    }

    handleStream(stream: any, context: ILLMRequestContext): EventEmitter {
        const emitter = new EventEmitter();
        const usage_data: any[] = [];
        const reportedUsage: any[] = [];
        let finishReason = 'stop';

        // Process stream asynchronously while as we need to return emitter immediately
        (async () => {
            let delta: Record<string, any> = {};

            let toolsData: any = [];

            for await (const part of stream) {
                delta = part.choices[0]?.delta;
                const usage = part.usage;

                if (usage) {
                    usage_data.push(usage);
                }
                emitter.emit('data', delta);

                if (!delta?.tool_calls && delta?.content) {
                    emitter.emit('content', delta?.content, delta?.role);
                }
                //_stream = toolCallsStream;
                if (delta?.tool_calls) {
                    const toolCall = delta?.tool_calls?.[0];
                    const index = toolCall?.index;

                    toolsData[index] = {
                        index,
                        role: 'tool',
                        id: (toolsData?.[index]?.id || '') + (toolCall?.id || ''),
                        type: (toolsData?.[index]?.type || '') + (toolCall?.type || ''),
                        name: (toolsData?.[index]?.name || '') + (toolCall?.function?.name || ''),
                        arguments: (toolsData?.[index]?.arguments || '') + (toolCall?.function?.arguments || ''),
                    };

                    continue;
                }
                if (part.choices[0]?.finish_reason) {
                    finishReason = part.choices[0]?.finish_reason;
                }
            }
            if (toolsData?.length > 0) {
                for (let tool of toolsData) {
                    if (tool.type.includes('functionfunction')) {
                        tool.type = 'function'; //path wrong tool call generated by LM Studio
                        //FIXME: use cleaner method to fix wrong tool call formats
                    }
                }
                emitter.emit(TLLMEvent.ToolInfo, toolsData);
            }

            usage_data.forEach((usage) => {
                // probably we can acc them and send them as one event
                const _reported = this.deps.reportUsage(usage, {
                    modelEntryName: context.modelEntryName,
                    keySource: context.isUserKey ? APIKeySource.User : APIKeySource.Smyth,
                    agentId: context.agentId,
                    teamId: context.teamId,
                });

                reportedUsage.push(_reported);
            });
            if (finishReason !== 'stop') {
                emitter.emit('interrupted', finishReason);
            }

            setTimeout(() => {
                emitter.emit('end', toolsData, reportedUsage, finishReason);
            }, 100);
        })();

        return emitter;
    }
} 